"""Report Generator for AI Employee Silver Tier.

Generates weekly activity reports and monthly financial reports.
"""

import os
import csv
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
from pathlib import Path

logger = logging.getLogger(__name__)


class ReportGenerator:
    """Generates automated reports for activity and financial tracking.

    Handles weekly activity reports, monthly financial reports, and custom reports.
    """

    def __init__(self, vault_path: str):
        """Initialize report generator.

        Args:
            vault_path: Path to AI_Employee_Vault
        """
        self.vault_path = Path(vault_path)

        # Ensure folders exist
        self._ensure_folders()

    def _ensure_folders(self):
        """Ensure required folders exist."""
        folders = [
            'Reports/weekly',
            'Reports/monthly',
            'Reports/custom'
        ]

        for folder in folders:
            folder_path = self.vault_path / folder
            folder_path.mkdir(parents=True, exist_ok=True)

    def generate_weekly_report(self) -> Dict[str, Any]:
        """Generate weekly activity report.

        Returns:
            Result dictionary with filepath
        """
        try:
            # Calculate date range (last 7 days)
            end_date = datetime.now()
            start_date = end_date - timedelta(days=7)

            date_range = {
                'start_date': start_date.strftime('%Y-%m-%d'),
                'end_date': end_date.strftime('%Y-%m-%d')
            }

            # Aggregate data
            by_source = self.aggregate_by_source(date_range['start_date'], date_range['end_date'])
            by_category = self.aggregate_by_category(date_range['start_date'], date_range['end_date'])
            time_saved = self.calculate_time_saved(date_range['start_date'], date_range['end_date'])

            # Generate markdown
            markdown = self._generate_weekly_markdown(date_range, by_source, by_category, time_saved)

            # Save report
            timestamp = datetime.now().strftime('%Y-%m-%d')
            filename = f"{timestamp}_weekly_report.md"
            filepath = self.vault_path / 'Reports' / 'weekly' / filename

            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(markdown)

            logger.info(f"Generated weekly report: {filepath}")

            return {
                'success': True,
                'filepath': str(filepath),
                'date_range': date_range
            }

        except Exception as e:
            logger.error(f"Error generating weekly report: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _generate_weekly_markdown(self, date_range: Dict, by_source: Dict, by_category: Dict, time_saved: float) -> str:
        """Generate markdown for weekly report.

        Args:
            date_range: Date range dictionary
            by_source: Items by source
            by_category: Items by category
            time_saved: Time saved in hours

        Returns:
            Markdown string
        """
        markdown = f"# Weekly Activity Report\n\n"
        markdown += f"**Period:** {date_range['start_date']} to {date_range['end_date']}\n"
        markdown += f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

        markdown += "---\n\n"

        # Items by source
        markdown += "## Items by Source\n\n"
        if by_source:
            for source, count in by_source.items():
                markdown += f"- **{source.title()}:** {count} items\n"
        else:
            markdown += "*No items processed this week*\n"
        markdown += "\n"

        # Top categories
        markdown += "## Top Categories\n\n"
        if by_category:
            sorted_categories = sorted(by_category.items(), key=lambda x: x[1], reverse=True)
            for category, count in sorted_categories[:5]:
                markdown += f"- **{category}:** {count} items\n"
        else:
            markdown += "*No categories this week*\n"
        markdown += "\n"

        # Time saved
        markdown += "## Productivity\n\n"
        markdown += f"**Estimated Time Saved:** {time_saved:.1f} hours\n\n"

        markdown += "---\n\n"
        markdown += "*Generated by AI Employee Silver Tier*\n"

        return markdown

    def generate_monthly_report(self) -> Dict[str, Any]:
        """Generate monthly financial report.

        Returns:
            Result dictionary with filepath
        """
        try:
            # Calculate date range (current month)
            now = datetime.now()
            start_date = now.replace(day=1).strftime('%Y-%m-%d')
            end_date = now.strftime('%Y-%m-%d')

            date_range = {
                'start_date': start_date,
                'end_date': end_date
            }

            # Aggregate financial data
            financial_data = self._aggregate_financial_data(start_date, end_date)

            # Generate markdown
            markdown = self._generate_monthly_markdown(date_range, financial_data)

            # Save report
            timestamp = now.strftime('%Y-%m')
            filename = f"{timestamp}_monthly_report.md"
            filepath = self.vault_path / 'Reports' / 'monthly' / filename

            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(markdown)

            # Export to CSV
            csv_path = self._export_monthly_csv(financial_data, timestamp)

            logger.info(f"Generated monthly report: {filepath}")

            return {
                'success': True,
                'filepath': str(filepath),
                'csv_path': csv_path,
                'date_range': date_range
            }

        except Exception as e:
            logger.error(f"Error generating monthly report: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _generate_monthly_markdown(self, date_range: Dict, financial_data: Dict) -> str:
        """Generate markdown for monthly report.

        Args:
            date_range: Date range dictionary
            financial_data: Financial data dictionary

        Returns:
            Markdown string
        """
        markdown = f"# Monthly Financial Report\n\n"
        markdown += f"**Period:** {date_range['start_date']} to {date_range['end_date']}\n"
        markdown += f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

        markdown += "---\n\n"

        # Invoices
        markdown += "## Invoices\n\n"
        markdown += f"- **Pending:** {financial_data.get('pending_invoices', 0)}\n"
        markdown += f"- **Paid:** {financial_data.get('paid_invoices', 0)}\n"
        markdown += f"- **Total Amount:** ${financial_data.get('total_invoices', 0):,.2f}\n\n"

        # Expenses
        markdown += "## Expenses\n\n"
        markdown += f"- **Total Expenses:** ${financial_data.get('total_expenses', 0):,.2f}\n"
        markdown += f"- **Budget:** ${financial_data.get('budget', 5000):,.2f}\n"
        markdown += f"- **Remaining:** ${financial_data.get('budget_remaining', 0):,.2f}\n\n"

        # Expenses by category
        if financial_data.get('expenses_by_category'):
            markdown += "### Expenses by Category\n\n"
            for category, amount in financial_data['expenses_by_category'].items():
                markdown += f"- **{category}:** ${amount:,.2f}\n"
            markdown += "\n"

        markdown += "---\n\n"
        markdown += "*Generated by AI Employee Silver Tier*\n"

        return markdown

    def _aggregate_financial_data(self, start_date: str, end_date: str) -> Dict[str, Any]:
        """Aggregate financial data for date range.

        Args:
            start_date: Start date string
            end_date: End date string

        Returns:
            Financial data dictionary
        """
        # Placeholder - would query database in production
        return {
            'pending_invoices': 0,
            'paid_invoices': 0,
            'total_invoices': 0,
            'total_expenses': 0,
            'budget': 5000,
            'budget_remaining': 5000,
            'expenses_by_category': {}
        }

    def _export_monthly_csv(self, financial_data: Dict, timestamp: str) -> str:
        """Export monthly data to CSV.

        Args:
            financial_data: Financial data dictionary
            timestamp: Timestamp string

        Returns:
            CSV file path
        """
        filename = f"{timestamp}_monthly_report.csv"
        filepath = self.vault_path / 'Reports' / 'monthly' / filename

        # Prepare CSV data
        rows = [
            ['Metric', 'Value'],
            ['Pending Invoices', financial_data.get('pending_invoices', 0)],
            ['Paid Invoices', financial_data.get('paid_invoices', 0)],
            ['Total Invoices', f"${financial_data.get('total_invoices', 0):,.2f}"],
            ['Total Expenses', f"${financial_data.get('total_expenses', 0):,.2f}"],
            ['Budget', f"${financial_data.get('budget', 5000):,.2f}"],
            ['Budget Remaining', f"${financial_data.get('budget_remaining', 0):,.2f}"]
        ]

        with open(filepath, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerows(rows)

        return str(filepath)

    def generate_custom_report(self, start_date: str, end_date: str) -> Dict[str, Any]:
        """Generate custom report for date range.

        Args:
            start_date: Start date string (YYYY-MM-DD)
            end_date: End date string (YYYY-MM-DD)

        Returns:
            Result dictionary with filepath
        """
        try:
            date_range = {
                'start_date': start_date,
                'end_date': end_date
            }

            # Aggregate data
            by_source = self.aggregate_by_source(start_date, end_date)
            by_category = self.aggregate_by_category(start_date, end_date)

            # Generate markdown
            markdown = f"# Custom Report\n\n"
            markdown += f"**Period:** {start_date} to {end_date}\n"
            markdown += f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            markdown += "---\n\n"
            markdown += "## Items by Source\n\n"

            if by_source:
                for source, count in by_source.items():
                    markdown += f"- **{source.title()}:** {count} items\n"
            else:
                markdown += "*No items in this period*\n"

            # Save report
            timestamp = datetime.now().strftime('%Y-%m-%d-%H%M%S')
            filename = f"{timestamp}_custom_report.md"
            filepath = self.vault_path / 'Reports' / 'custom' / filename

            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(markdown)

            logger.info(f"Generated custom report: {filepath}")

            return {
                'success': True,
                'filepath': str(filepath),
                'date_range': date_range
            }

        except Exception as e:
            logger.error(f"Error generating custom report: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def aggregate_by_source(self, start_date: str, end_date: str) -> Dict[str, int]:
        """Aggregate items by source.

        Args:
            start_date: Start date string
            end_date: End date string

        Returns:
            Dictionary mapping source to count
        """
        # Placeholder - would query database in production
        return {
            'email': 0,
            'whatsapp': 0,
            'linkedin': 0,
            'files': 0
        }

    def aggregate_by_category(self, start_date: str, end_date: str) -> Dict[str, int]:
        """Aggregate items by category.

        Args:
            start_date: Start date string
            end_date: End date string

        Returns:
            Dictionary mapping category to count
        """
        # Placeholder - would query database in production
        return {}

    def calculate_time_saved(self, start_date: str, end_date: str) -> float:
        """Calculate time saved by automation.

        Args:
            start_date: Start date string
            end_date: End date string

        Returns:
            Time saved in hours
        """
        # Placeholder - would calculate based on processed items
        # Assume 5 minutes saved per item
        total_items = sum(self.aggregate_by_source(start_date, end_date).values())
        return (total_items * 5) / 60  # Convert minutes to hours

    def export_to_csv(self, data: Dict[str, List], filename: str) -> str:
        """Export data to CSV file.

        Args:
            data: Dictionary with column names as keys and lists as values
            filename: Base filename (without extension)

        Returns:
            CSV file path
        """
        filepath = self.vault_path / 'Reports' / 'custom' / f"{filename}.csv"

        # Get column names and rows
        columns = list(data.keys())
        num_rows = len(data[columns[0]]) if columns else 0

        rows = [columns]
        for i in range(num_rows):
            row = [data[col][i] for col in columns]
            rows.append(row)

        with open(filepath, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerows(rows)

        return str(filepath)
